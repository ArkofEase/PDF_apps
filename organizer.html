<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Page Organizer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script src="https://unpkg.com/pdf-lib@1.17.1/dist/pdf-lib.min.js"></script>
    <script src="https://unpkg.com/@pdf-lib/fontkit/dist/fontkit.umd.js"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">
    <style>
        body { font-family: 'Inter', sans-serif; background-color: #f1f5f9; overflow: hidden; height: 100vh; display: flex; flex-direction: column; }
        #pages-wrapper {
            display: grid; gap: 3.5rem; padding: 4rem; justify-items: center;
            grid-template-columns: repeat(auto-fill, minmax(var(--page-width, 400px), 1fr));
        }
        .page-container { position: relative; background: white; border-radius: 12px; border: 4px solid transparent; transition: all 0.2s; height: fit-content; }
        .page-container.selected { border-color: #3b82f6 !important; box-shadow: 0 0 35px rgba(59, 130, 246, 0.7) !important; transform: translateY(-5px); z-index: 100; }
        
        .drop-before { border-left: 10px solid #3b82f6 !important; }
        .drop-after { border-right: 10px solid #3b82f6 !important; }

        .page-header { background: #1e293b; color: white; padding: 10px 14px; display: flex; justify-content: space-between; align-items: center; border-radius: 12px 12px 0 0; cursor: grab; }
        .h-btn { padding: 6px; border-radius: 6px; cursor: pointer; transition: 0.2s; position: relative; z-index: 2000; }
        .h-btn:hover { background: rgba(255,255,255,0.2); }
        .canvas-wrapper { line-height: 0; border: 1px solid #e2e8f0; border-radius: 0 0 12px 12px; overflow: hidden; background: #f8fafc; position: relative; }
        canvas { display: block; width: 100%; height: auto; }
        
        /* 모달 스타일 */
        .modal-overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.8); z-index: 9999; display: none; align-items: center; justify-content: center; backdrop-filter: blur(5px); }
        .modal-box { background: white; padding: 2.5rem; border-radius: 24px; width: 420px; box-shadow: 0 25px 50px -12px rgba(0,0,0,0.5); text-align: center; }
        
        #loader { position: fixed; inset: 0; background: rgba(15, 23, 42, 0.9); z-index: 9999; display: none; align-items: center; justify-content: center; flex-direction: column; color: white; }

        #mode-org.mode-active,
        #mode-txt.mode-active {
            background-color: #2563eb;
            color: white;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        }
        #mode-org.mode-active { font-weight: 900; }

        .tooltip-container { position: relative; display: inline-block; margin-left: 8px; }
        .tooltip-text {
            visibility: hidden; width: 280px; background-color: #1e293b; color: #fff; text-align: left;
            border-radius: 8px; padding: 12px; position: absolute; z-index: 9999;
            top: 140%; left: 50%; transform: translateX(-50%); opacity: 0; transition: opacity 0.3s;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.5); font-size: 11px; line-height: 1.5; pointer-events: none;
            border: 1px solid #475569;
        }
        .tooltip-container:hover .tooltip-text { visibility: visible; opacity: 1; }
        .tooltip-arrow { position: absolute; bottom: 100%; left: 50%; margin-left: -5px; border-width: 5px; border-style: solid; border-color: transparent transparent #1e293b transparent; }
    </style>
</head>
<body>

    <header class="bg-slate-900 text-white p-4 flex justify-between items-center shadow-2xl z-[5000]">
        <div class="flex items-center gap-6">
            <div class="flex items-center gap-3">
                <div class="w-10 h-10 bg-blue-600 rounded-lg flex items-center justify-center shadow-lg transform -rotate-6"><i class="fas fa-box-archive text-white text-lg"></i></div>
                <h1 class="font-black text-2xl tracking-tighter text-blue-500 italic uppercase">PAGE ORGANIZER</h1>
            </div>
            
            <div class="tooltip-container">
                <div class="w-8 h-8 rounded-full bg-slate-800 border border-slate-600 flex items-center justify-center text-xs text-blue-400 cursor-help hover:bg-blue-600 hover:text-white hover:border-blue-500 transition-all shadow-md"><i class="fas fa-question"></i></div>
                <div class="tooltip-text">
                    <div class="tooltip-arrow"></div>
                    <strong class="text-blue-400 block mb-1 uppercase">How to Use</strong>
                    <ul class="list-disc pl-4 space-y-1 text-slate-300">
                        <li>Multi-select pages: <span class="text-white font-bold">Hold 'Ctrl' + Click</span></li>
                        <li>Create a note: Switch to <span class="text-white font-bold">'Write Note'</span> mode, then click anywhere on the page.</li>
                        <li><span class="text-yellow-400">Tip:</span> Notes and Stamps can be edited or deleted by clicking on them.</li>
                    </ul>
                </div>
            </div>

            <a href="vip_Ehera_PDF.html" class="flex items-center gap-2 bg-slate-800 hover:bg-slate-700 border border-slate-600 text-slate-300 px-4 py-2 rounded-lg font-bold text-[10px] uppercase shadow-lg transition-all"><i class="fas fa-home text-blue-400"></i><span>Home</span></a>
            
            <div class="flex items-center bg-slate-800 p-1 rounded-xl border border-slate-700">
                <button onclick="App.undo()" id="btn-undo" class="px-3 py-1.5 rounded-lg text-[10px] font-black uppercase text-slate-400 hover:text-white disabled:opacity-20" disabled><i class="fas fa-undo mr-1"></i> Undo</button>
                <div class="w-[1px] bg-slate-700 mx-2"></div>
                <button onclick="App.setMode('organize')" id="mode-org" class="px-5 py-2 rounded-lg text-xs font-black uppercase text-slate-300 hover:text-white hover:bg-slate-700/50 transition-all mode-active">ORGANIZE PAGES</button>
                <button onclick="App.setMode('text')" id="mode-txt" class="ml-1 px-3 py-1.5 rounded-lg text-[10px] font-bold uppercase text-slate-500 hover:text-slate-200 hover:bg-slate-700/50 transition-all">Write Note</button>
            </div>

            <div id="text-tools" class="flex items-center gap-3 bg-slate-800 px-3 py-1.5 rounded-xl border border-slate-700 opacity-30 transition-opacity">
                <input type="color" id="text-color" value="#ff0000" class="w-6 h-6 rounded cursor-pointer bg-transparent border-none">
                <div class="flex items-center gap-2 text-[10px] font-bold text-slate-400 uppercase">
                    <span>Size:</span>
                    <input type="number" id="text-size" value="12" min="1" max="200" class="w-16 bg-slate-900 border border-slate-700 text-white rounded px-2 py-1 focus:outline-none focus:border-blue-500">
                </div>
                <div class="w-[1px] h-4 bg-slate-600 mx-1"></div>
                <button onclick="App.addHeaderStamp()" class="text-slate-400 hover:text-yellow-400 transition-colors" title="Add Header Stamp">
                    <i class="fas fa-stamp text-lg"></i>
                </button>
            </div>
        </div>
        
        <div class="flex items-center gap-4">
            <div id="bulk-toolbar" class="hidden flex items-center gap-3 bg-blue-600/20 px-4 py-2 rounded-xl border border-blue-500">
                <button onclick="App.bulkRotate()" class="text-blue-400 font-bold text-[10px] uppercase">Rotate All</button>
                <button onclick="App.bulkDelete()" class="text-red-400 font-bold text-[10px] uppercase">Delete All</button>
            </div>
            <button onclick="App.selectAll()" id="btn-select-all" class="bg-slate-700 hover:bg-slate-600 px-4 py-2 rounded-xl font-bold text-[10px] uppercase disabled:opacity-30" disabled>Select All</button>
            <button onclick="App.insertBlankAtEnd()" class="bg-slate-700 hover:bg-slate-600 px-4 py-2 rounded-xl font-bold text-[10px] uppercase">Add Blank</button>
            <input type="range" id="zoom-slider" min="200" max="1200" value="400" class="w-32 accent-blue-500 cursor-pointer">
            <button onclick="document.getElementById('file-input').click()" class="bg-blue-600 hover:bg-blue-500 px-5 py-2 rounded-xl font-black text-[10px] uppercase">Open PDF</button>
            <input type="file" id="file-input" class="hidden" accept="application/pdf, image/*">
            <button onclick="App.savePDF()" id="btn-save" class="bg-emerald-600 hover:bg-emerald-500 px-6 py-2 rounded-xl font-black text-[10px] uppercase disabled:opacity-30" disabled>Save</button>
        </div>
    </header>

    <main class="flex-1 overflow-auto bg-slate-200 relative" id="workspace">
        <div id="pages-wrapper"></div>
    </main>

    <div id="modal-overlay" class="modal-overlay">
        <div class="modal-box">
            <h2 class="text-2xl font-black text-slate-900 mb-2 uppercase">Image Import</h2>
            <div class="grid grid-cols-2 gap-4 mb-6">
                <button onclick="App.finalizeImage('letter')" class="p-5 border-2 border-slate-100 hover:border-blue-600 rounded-2xl flex flex-col items-center group transition-all"><i class="fas fa-file-invoice text-3xl mb-3 text-slate-300 group-hover:text-blue-600"></i><span class="text-[11px] font-black uppercase text-slate-700">Fit to Letter</span></button>
                <button onclick="App.finalizeImage('original')" class="p-5 border-2 border-slate-100 hover:border-emerald-500 rounded-2xl flex flex-col items-center group transition-all"><i class="fas fa-image text-3xl mb-3 text-slate-300 group-hover:text-emerald-500"></i><span class="text-[11px] font-black uppercase text-slate-700">Original Size</span></button>
            </div>
            <button onclick="App.closeModal()" class="text-[10px] font-bold text-slate-400 uppercase tracking-widest hover:text-slate-600">Cancel</button>
        </div>
    </div>

    <div id="note-overlay" class="modal-overlay">
        <div class="modal-box" style="width: 500px;">
            <h2 class="text-xl font-black text-slate-900 mb-4 uppercase">Edit Note</h2>
            <textarea id="note-input" class="w-full h-40 bg-slate-100 border border-slate-300 rounded-xl p-4 text-sm font-bold text-slate-700 mb-6 focus:outline-none focus:border-blue-500 resize-none" placeholder="Type your note here... (Enter for new line)"></textarea>
            <div class="flex gap-3 justify-center">
                <button onclick="App.deleteCurrentNote()" id="btn-delete-note" class="px-6 py-3 rounded-xl bg-red-100 text-red-500 font-black text-[10px] uppercase hover:bg-red-200 transition-colors hidden">Delete</button>
                <button onclick="App.closeNoteModal()" class="px-6 py-3 rounded-xl bg-slate-100 text-slate-400 font-black text-[10px] uppercase hover:bg-slate-200 transition-colors">Cancel</button>
                <button onclick="App.confirmNote()" class="px-8 py-3 rounded-xl bg-blue-600 text-white font-black text-[10px] uppercase hover:bg-blue-500 transition-colors shadow-lg">Save Note</button>
            </div>
        </div>
    </div>

    <!-- New Stamp Modal -->
    <div id="stamp-overlay" class="modal-overlay">
        <div class="modal-box" style="width: 400px;">
            <h2 class="text-xl font-black text-slate-900 mb-4 uppercase">Header Stamp</h2>
            <input type="text" id="stamp-input" class="w-full bg-slate-100 border border-slate-300 rounded-xl p-4 text-sm font-bold text-slate-700 mb-6 focus:outline-none focus:border-blue-500" placeholder="Enter stamp text (e.g. DRAFT)">
            <div class="flex gap-3 justify-center">
                <button onclick="App.closeStampModal()" class="px-6 py-3 rounded-xl bg-slate-100 text-slate-400 font-black text-[10px] uppercase hover:bg-slate-200 transition-colors">Cancel</button>
                <button onclick="App.confirmStamp()" class="px-8 py-3 rounded-xl bg-blue-600 text-white font-black text-[10px] uppercase hover:bg-blue-500 transition-colors shadow-lg">Apply Stamp</button>
            </div>
        </div>
    </div>

    <div id="loader"><div class="animate-spin rounded-full h-12 w-12 border-b-2 border-white mb-4"></div><p id="loader-text" class="text-xs font-black uppercase">Processing Data...</p></div>

    <script>
        const pdfjsLib = window.pdfjsLib; // Fixed: Correctly referencing the global variable
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

        const App = {
            pages: [], selectedPageIds: new Set(), pdfCache: new Map(), mode: 'organize', history: [], tempFile: null, tempIdx: null, dragId: null,
            noteState: { active: false, pageId: null, textIndex: null, x: 0, y: 0 },

            showLoader: (m) => { const el = document.getElementById('loader'); if(el) { document.getElementById('loader-text').innerText = m; el.style.display = 'flex'; } },
            hideLoader: () => { const el = document.getElementById('loader'); if(el) el.style.display = 'none'; },
            
            openModal: () => document.getElementById('modal-overlay').style.display = 'flex',
            closeModal: () => { document.getElementById('modal-overlay').style.display = 'none'; App.tempFile = null; },

            openNoteModal: (content, pageId, textIndex, x, y) => {
                App.noteState = { active: true, pageId, textIndex, x, y };
                const input = document.getElementById('note-input');
                input.value = content || "";
                document.getElementById('btn-delete-note').style.display = (textIndex !== null) ? 'block' : 'none';
                document.getElementById('note-overlay').style.display = 'flex';
                input.focus();
            },
            closeNoteModal: () => {
                document.getElementById('note-overlay').style.display = 'none';
                App.noteState = { active: false, pageId: null, textIndex: null, x: 0, y: 0 };
            },
            deleteCurrentNote: () => {
                if (App.noteState.textIndex !== null) {
                    App.saveState();
                    const p = App.pages.find(page => page.id === App.noteState.pageId);
                    if (p) p.texts.splice(App.noteState.textIndex, 1);
                    App.renderPages();
                }
                App.closeNoteModal();
            },
            confirmNote: () => {
                const content = document.getElementById('note-input').value;
                if (!content.trim()) { App.deleteCurrentNote(); return; }

                App.saveState();
                const p = App.pages.find(page => page.id === App.noteState.pageId);
                if (p) {
                    if (App.noteState.textIndex !== null) {
                        p.texts[App.noteState.textIndex].content = content;
                    } else {
                        p.texts.push({
                            x: App.noteState.x,
                            y: App.noteState.y,
                            content: content,
                            color: document.getElementById('text-color').value,
                            size: parseInt(document.getElementById('text-size').value)
                        });
                    }
                }
                App.renderPages();
                App.closeNoteModal();
            },

            openStampModal: () => {
                document.getElementById('stamp-input').value = "DRAFT";
                document.getElementById('stamp-overlay').style.display = 'flex';
                document.getElementById('stamp-input').focus();
            },
            closeStampModal: () => {
                document.getElementById('stamp-overlay').style.display = 'none';
            },
            confirmStamp: () => {
                const text = document.getElementById('stamp-input').value;
                if (!text.trim()) { App.closeStampModal(); return; }

                const color = document.getElementById('text-color').value;
                const size = parseInt(document.getElementById('text-size').value, 10) || 24;

                App.saveState();
                
                // Stamp all pages regardless of selection
                const targetIds = App.pages.map(p => p.id);
                
                targetIds.forEach(id => {
                    const p = App.pages.find(page => page.id === id);
                    if(p) {
                        p.texts.push({
                            x: 40, // Left alignment
                            y: 40,
                            content: text,
                            color: color,
                            size: size,
                        });
                    }
                });
                App.renderPages();
                App.closeStampModal();
            },

            addHeaderStamp: () => {
                App.openStampModal();
            },

            init: () => {
                document.getElementById('file-input').onchange = App.loadFile;
                document.getElementById('zoom-slider').oninput = (e) => document.documentElement.style.setProperty('--page-width', e.target.value + 'px');
                App.initDND();
            },

            initDND: () => {
                const ws = document.getElementById('workspace');
                ws.ondragover = (e) => e.preventDefault();
                ws.ondrop = async (e) => {
                    e.preventDefault();
                    const rects = Array.from(document.querySelectorAll('.page-container')).map(el => ({ id: el.dataset.id, rect: el.getBoundingClientRect() }));
                    let targetIdx = App.pages.length;
                    for (let i = 0; i < rects.length; i++) {
                        const r = rects[i].rect;
                        const isRowMatch = e.clientY > r.top && e.clientY < r.bottom;
                        if (e.clientY < r.top || (isRowMatch && e.clientX < r.left + r.width / 2)) {
                            targetIdx = i;
                            break;
                        }
                    }

                    if (e.dataTransfer.files.length > 0) {
                        const file = e.dataTransfer.files[0];
                        if (file.type === 'application/pdf') await App.insertPDF(file, targetIdx);
                        else if (file.type.startsWith('image/')) { App.tempFile = file; App.tempIdx = targetIdx; App.openModal(); }
                    } else if (App.dragId) {
                        App.saveState();
                        const from = App.pages.findIndex(x => x.id === App.dragId);
                        const [item] = App.pages.splice(from, 1);
                        const adjTo = (from < targetIdx) ? targetIdx - 1 : targetIdx;
                        App.pages.splice(Math.max(0, adjTo), 0, item); App.renderPages();
                    }
                };
            },

            insertPDF: async (file, targetIdx) => {
                App.showLoader("INSERTING PDF...");
                try {
                    const buf = await file.arrayBuffer();
                    // Keep one reference to the file bytes to ensure caching works (object identity)
                    const fileBytes = new Uint8Array(buf);
                    const pdf = await pdfjsLib.getDocument({ data: new Uint8Array(buf.slice(0)) }).promise;
                    App.saveState();
                    for (let i = 1; i <= pdf.numPages; i++) {
                        App.pages.splice(targetIdx + i - 1, 0, { id: Math.random().toString(36).substr(2,9), originalIndex: i-1, rotation: 0, sourceBytes: fileBytes, texts: [], isBlank: false });
                    }
                    await App.renderPages();
                } finally { App.hideLoader(); }
            },

            finalizeImage: async (pref) => {
                const f = App.tempFile; const idx = App.tempIdx; App.closeModal();
                App.showLoader("IMPORTING...");
                const r = new FileReader();
                r.onload = async (ev) => {
                    App.saveState();
                    App.pages.splice(idx, 0, { id: Math.random().toString(36).substr(2,9), rotation: 0, texts: [], isBlank: false, isImage: true, imageBytes: new Uint8Array(ev.target.result), imageType: f.type, imageSizePref: pref, sourceBytes: null });
                    await App.renderPages(); App.hideLoader();
                };
                r.readAsArrayBuffer(f);
            },

            saveState: () => {
                // IMPORTANT: We slice(0) sourceBytes to ensure the history stack is immutable.
                // Note: This breaks object identity for cache, so cache invalidates on undo.
                const state = App.pages.map(p => ({ ...p, texts: JSON.parse(JSON.stringify(p.texts || [])), sourceBytes: p.sourceBytes ? p.sourceBytes.slice(0) : null, imageBytes: p.imageBytes ? p.imageBytes.slice(0) : null }));
                App.history.push(state);
                if (App.history.length > 20) App.history.shift();
                document.getElementById('btn-undo').disabled = false;
            },

            undo: () => { if (App.history.length === 0) return; App.pages = App.history.pop(); document.getElementById('btn-undo').disabled = App.history.length === 0; App.selectedPageIds.clear(); App.renderPages(); },
            selectAll: () => { if (App.pages.length === 0) return; if (App.selectedPageIds.size === App.pages.length) App.selectedPageIds.clear(); else App.pages.forEach(p => App.selectedPageIds.add(p.id)); App.updateUI(); },
            
            setMode: (m) => { 
                App.mode = m; 
                document.getElementById('mode-org').classList.toggle('mode-active', m === 'organize'); 
                document.getElementById('mode-txt').classList.toggle('mode-active', m === 'text'); 
                document.getElementById('text-tools').style.opacity = (m === 'text') ? '1' : '0.3';
                document.querySelectorAll('.page-container').forEach(el => el.draggable = (m === 'organize'));
                App.updateUI(); 
            },

            loadFile: async (e) => {
                const f = e.target.files[0]; if (!f) return;
                try {
                    App.showLoader("ANALYZING PDF...");
                    const buf = await f.arrayBuffer();
                    // Fix: Use window.pdfjsLib correctly
                    const pdf = await pdfjsLib.getDocument({ data: new Uint8Array(buf.slice(0)) }).promise;
                    App.saveState(); App.pages = [];
                    // Fix: Create one shared Uint8Array for all pages from this file to enable caching
                    const fileBytes = new Uint8Array(buf);
                    for (let i = 1; i <= pdf.numPages; i++) { 
                        App.pages.push({ 
                            id: Math.random().toString(36).substr(2,9), 
                            originalIndex: i-1, 
                            rotation: 0, 
                            sourceBytes: fileBytes, 
                            texts: [], 
                            isBlank: false 
                        }); 
                    }
                    await App.renderPages(); document.getElementById('btn-select-all').disabled = false; document.getElementById('btn-save').disabled = false;
                } catch (err) { alert("Load Error: " + err.message); } finally { App.hideLoader(); e.target.value = ''; }
            },

            renderPages: async () => {
                const wrapper = document.getElementById('pages-wrapper'); wrapper.innerHTML = '';
                App.showLoader("RENDERING...");
                try {
                    for (let i = 0; i < App.pages.length; i++) {
                        const p = App.pages[i];
                        const container = document.createElement('div');
                        container.className = `page-container ${App.selectedPageIds.has(p.id) ? 'selected' : ''}`;
                        container.dataset.id = p.id;
                        container.draggable = (App.mode === 'organize');

                        const header = document.createElement('div');
                        header.className = 'page-header text-[9px] font-black uppercase';
                        header.innerHTML = `<span>${p.isImage ? 'IMAGE' : (p.isBlank ? 'BLANK' : 'PAGE '+(i+1))}</span>
                            <div class="flex gap-1">
                                <button onclick="event.stopPropagation(); App.rotateSingle('${p.id}')" class="h-btn text-blue-300"><i class="fas fa-redo"></i></button>
                                <button onclick="event.stopPropagation(); App.duplicatePage('${p.id}')" class="h-btn text-emerald-400"><i class="fas fa-copy"></i></button>
                                <button onclick="event.stopPropagation(); App.insertBlankAfter('${p.id}')" class="h-btn text-yellow-400"><i class="fas fa-plus"></i></button>
                                <button onclick="event.stopPropagation(); App.deletePage('${p.id}')" class="h-btn text-red-400"><i class="fas fa-trash-alt"></i></button>
                            </div>`;

                        const canvas = document.createElement('canvas');
                        const ctx = canvas.getContext('2d');

                        if (p.isImage && p.imageBytes) {
                            const img = new Image(); const url = URL.createObjectURL(new Blob([p.imageBytes], {type:p.imageType}));
                            await new Promise(r => { img.onload = r; img.src = url; });
                            const isL = p.rotation % 180 !== 0;
                            const drawW = p.imageSizePref === 'letter' ? 612 : img.width;
                            const drawH = p.imageSizePref === 'letter' ? 792 : img.height;
                            canvas.width = isL ? drawH : drawW; canvas.height = isL ? drawW : drawH;
                            ctx.save(); ctx.translate(canvas.width / 2, canvas.height / 2); ctx.rotate((p.rotation * Math.PI) / 180);
                            if (p.imageSizePref === 'letter') { ctx.fillStyle = "white"; ctx.fillRect(-306, -396, 612, 792); const s = Math.min(612/img.width, 792/img.height); ctx.drawImage(img, -(img.width*s)/2, -(img.height*s)/2, img.width*s, img.height*s); }
                            else { ctx.drawImage(img, -img.width/2, -img.height/2); }
                            ctx.restore(); URL.revokeObjectURL(url);
                        } else if (!p.isBlank && p.sourceBytes) {
                            // Fix: Caching now works because sourceBytes object reference is shared across pages
                            let doc = App.pdfCache.get(p.sourceBytes); if (!doc) { doc = await pdfjsLib.getDocument({ data: p.sourceBytes.slice(0) }).promise; App.pdfCache.set(p.sourceBytes, doc); }
                            const page = await doc.getPage(p.originalIndex + 1);
                            const vp = page.getViewport({ scale: 1.5, rotation: (page.rotate + p.rotation) % 360 });
                            canvas.width = vp.width; canvas.height = vp.height; await page.render({ canvasContext: ctx, viewport: vp }).promise;
                        } else { canvas.width = 612; canvas.height = 792; ctx.fillStyle = "white"; ctx.fillRect(0,0,612,792); }

                        p.texts.forEach(t => { 
                            ctx.fillStyle = t.color || "#ff0000"; 
                            ctx.font = `bold ${t.size || 12}px Arial`; 
                            
                            const lines = t.content.split('\n');
                            const lineHeight = (t.size || 12) * 1.2;
                            lines.forEach((line, i) => {
                                ctx.fillText(line, t.x, t.y + (i * lineHeight));
                            });

                            t.width = Math.max(...lines.map(l => ctx.measureText(l).width));
                            t.height = lineHeight * lines.length;
                        });

                        canvas.onclick = (e) => {
                            if (App.mode !== 'text') return;
                            const r = canvas.getBoundingClientRect();
                            const x = (e.clientX - r.left) * (canvas.width / r.width);
                            const y = (e.clientY - r.top) * (canvas.height / r.height);

                            const clickedTextIdx = p.texts.findIndex(t => 
                                x >= t.x && x <= t.x + (t.width || 50) &&
                                y >= t.y - (t.size || 12) && y <= t.y + (t.height || 12)
                            );

                            if (clickedTextIdx !== -1) {
                                App.openNoteModal(p.texts[clickedTextIdx].content, p.id, clickedTextIdx, 0, 0);
                                return;
                            }

                            ctx.save();
                            ctx.strokeStyle = "red"; ctx.lineWidth = 2;
                            ctx.beginPath(); ctx.moveTo(x-10, y); ctx.lineTo(x+10, y); ctx.stroke();
                            ctx.beginPath(); ctx.moveTo(x, y-10); ctx.lineTo(x, y+10); ctx.stroke();
                            ctx.restore();

                            setTimeout(() => {
                                App.openNoteModal("", p.id, null, x, y);
                            }, 10);
                        };

                        container.ondragover = (e) => {
                            e.preventDefault();
                            const r = container.getBoundingClientRect();
                            const mX = r.left + r.width / 2;
                            container.classList.toggle('drop-before', e.clientX < mX);
                            container.classList.toggle('drop-after', e.clientX >= mX);
                        };
                        container.ondragleave = () => { container.classList.remove('drop-before', 'drop-after'); };

                        container.onmousedown = (e) => {
                            if (e.target.closest('.h-btn')) return;
                            if (!e.ctrlKey && !App.selectedPageIds.has(p.id)) App.selectedPageIds.clear();
                            App.selectedPageIds.add(p.id); App.updateUI();
                        };

                        container.ondragstart = () => App.dragId = p.id;
                        
                        const cw = document.createElement('div'); cw.className = 'canvas-wrapper'; cw.appendChild(canvas); container.appendChild(header); container.appendChild(cw); wrapper.appendChild(container);
                    }
                } finally { App.hideLoader(); App.updateUI(); }
            },

            rotateSingle: (id) => { App.saveState(); const p = App.pages.find(x => x.id === id); p.rotation = (p.rotation + 90) % 360; App.renderPages(); },
            bulkRotate: () => { App.saveState(); App.selectedPageIds.forEach(id => { const p = App.pages.find(x => x.id === id); p.rotation = (p.rotation + 90) % 360; }); App.renderPages(); },
            duplicatePage: (id) => { App.saveState(); const idx = App.pages.findIndex(x => x.id === id); const p = App.pages[idx]; const clone = { ...p, id: Math.random().toString(36).substr(2,9), texts: JSON.parse(JSON.stringify(p.texts)) }; App.pages.splice(idx + 1, 0, clone); App.renderPages(); },
            insertBlankAfter: (id) => { App.saveState(); const idx = App.pages.findIndex(p => p.id === id); App.pages.splice(idx + 1, 0, { id: Math.random().toString(36).substr(2,9), rotation: 0, texts: [], isBlank: true, sourceBytes: null }); App.renderPages(); },
            insertBlankAtEnd: () => { App.saveState(); App.pages.push({ id: Math.random().toString(36).substr(2,9), rotation: 0, texts: [], isBlank: true, sourceBytes: null }); App.renderPages(); },
            deletePage: (id) => { App.saveState(); App.pages = App.pages.filter(p => p.id !== id); App.selectedPageIds.delete(id); App.renderPages(); },
            bulkDelete: () => { App.saveState(); App.pages = App.pages.filter(p => !App.selectedPageIds.has(p.id)); App.selectedPageIds.clear(); App.renderPages(); },
            
            updateUI: () => {
                document.querySelectorAll('.page-container').forEach(el => el.classList.toggle('selected', App.selectedPageIds.has(el.dataset.id)));
                const bar = document.getElementById('bulk-toolbar'); bar.classList.toggle('hidden', App.selectedPageIds.size === 0);
                const btn = document.getElementById('btn-select-all'); if(btn) btn.innerText = (App.selectedPageIds.size === App.pages.length && App.pages.length > 0) ? "Deselect All" : "Select All";
            },

            savePDF: async () => {
                App.showLoader("LOADING KOREAN FONT...");
                try {
                    const { PDFDocument, degrees, rgb } = PDFLib; 
                    const out = await PDFDocument.create();
                    out.registerFontkit(fontkit);

                    const fontBytes = await fetch('https://cdn.jsdelivr.net/gh/beomjungil/Noto-Sans-KR/NotoSans-Regular.ttf').then(res => res.arrayBuffer());
                    const font = await out.embedFont(fontBytes);

                    const hexToRgb = (hex) => { const r = parseInt(hex.slice(1, 3), 16) / 255; const g = parseInt(hex.slice(3, 5), 16) / 255; const b = parseInt(hex.slice(5, 7), 16) / 255; return rgb(r, g, b); };
                    const docMap = new Map();
                    for (const p of App.pages) {
                        let page;
                        if (p.isImage && p.imageBytes) {
                            const img = p.imageType === 'image/png' ? await out.embedPng(p.imageBytes.slice(0)) : await out.embedJpg(p.imageBytes.slice(0));
                            const isL = p.rotation % 180 !== 0; const drawW = p.imageSizePref === 'letter' ? 612 : img.width; const drawH = p.imageSizePref === 'letter' ? 792 : img.height;
                            page = out.addPage(isL ? [drawH, drawW] : [drawW, drawH]); page.setRotation(degrees(p.rotation));
                            if (p.imageSizePref === 'letter') { const s = Math.min(612/img.width, 792/img.height); page.drawImage(img, { x: (612-img.width*s)/2, y: (792-img.height*s)/2, width: img.width*s, height: img.height*s }); }
                            else { page.drawImage(img, { x: 0, y: 0, width: img.width, height: img.height }); }
                        } else if (p.isBlank || !p.sourceBytes) { page = out.addPage([612, 792]); page.setRotation(degrees(p.rotation)); }
                        else {
                            if (!docMap.has(p.sourceBytes)) docMap.set(p.sourceBytes, await PDFDocument.load(p.sourceBytes.slice(0)));
                            const src = docMap.get(p.sourceBytes); const [copied] = await out.copyPages(src, [p.originalIndex]);
                            copied.setRotation(degrees((copied.getRotation().angle + p.rotation) % 360)); page = out.addPage(copied);
                        }
                        const { width, height } = page.getSize();
                        p.texts.forEach(t => { 
                            const isL = p.rotation % 180 !== 0; const rW = isL ? 1188 : 918, rH = isL ? 918 : 1188;
                            page.drawText(t.content, { 
                                x: (t.x / rW) * width, 
                                y: height - (t.y / rH) * height, 
                                size: (t.size / 1.5), 
                                font, 
                                color: hexToRgb(t.color || "#ff0000"),
                                lineHeight: (t.size / 1.5) * 1.2 
                            });
                        });
                    }
                    
                    const b = await out.save(); const l = document.createElement('a'); l.href = URL.createObjectURL(new Blob([b], {type:'application/pdf'})); l.download = "Ehera_Final_Review.pdf"; l.click();
                } catch(e) { alert("Save Error: " + e.message); } finally { App.hideLoader(); }
            }
        };
        App.init();
    </script>
</body>
</html>